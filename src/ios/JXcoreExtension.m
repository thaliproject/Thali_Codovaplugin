//
//  JXcoreExtension.m
//  Thali
//
//  Copyright (C) Microsoft. All rights reserved.
//  Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//

#import "JXcore.h"
#import "JXcoreExtension.h"
// To use swift code (AppContext.swift) in objc we need to import autogenerated
// bridging header. PROJECT_NAME pattern is replaced with actual project name
// during before_plugin_install phase
#import "%PROJECT_NAME%-swift.h"

// JXcoreExtension implementation.
@interface JXcoreExtension (AppContextDelegate) <AppContextDelegate>

@end

@implementation JXcoreExtension

- (instancetype)init {
    if (self = [super init]) {
        return self;
    }
    return nil;
}

#pragma mark - Define public API to node methods

// Defines methods.
- (void)defineMethods {
    static AppContext * appContext = nil;

    if (!appContext) {
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            appContext = [[AppContext alloc] initWithServiceType:@"thaliproject"];
        });
    }
    appContext.delegate = self;

    // Handler for didRegisterToNative should be registered before other node functions that
    // firing didRegisterToNative call
    [self defineDidRegisterToNative:appContext];

    // Export the public API to node
    [self defineStartListeningForAdvertisements:appContext];
    [self defineStopListeningForAdvertisements:appContext];
    [self defineStartUpdateAdvertisingAndListening:appContext];
    [self defineStopAdvertisingAndListening:appContext];
    [self defineMultiConnect:appContext];
    [self defineKillConnections:appContext];
    [self defineGetOSVersion:appContext];
    [self defineDisconnect:appContext];
    [self defineConnect:appContext];
#ifdef TEST
    [self defineExecuteNativeTests:appContext];
#endif
}

- (void)handleCallback:(NSString *)callback error:(NSError *)error {
    if (error == nil) {
        [JXcore callEventCallback:callback withParams:@[[NSNull null]]];
    } else {
        [JXcore callEventCallback:callback withParams:@[error.localizedDescription]];
    }
}

- (void)defineStartListeningForAdvertisements:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString * callbackId) {
        NSError *error = nil;
        [appContext startListeningForAdvertisementsAndReturnError:&error];
        [self handleCallback:callbackId error:error];
    } withName:[AppContextJSEvent startListeningForAdvertisements]];
}

- (void)defineStopListeningForAdvertisements:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString * callbackId) {
        NSError *error = nil;
        [appContext stopListeningForAdvertisementsAndReturnError:&error];
        [self handleCallback:callbackId error:error];
    } withName:[AppContextJSEvent stopListeningForAdvertisements]];
}

- (void)defineStartUpdateAdvertisingAndListening:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString * callbackId) {
        NSError *error = nil;
        [appContext startUpdateAdvertisingAndListeningWithParameters:params error:&error];
        [self handleCallback:callbackId error:error];
    } withName:[AppContextJSEvent startUpdateAdvertisingAndListening]];
}

- (void)defineStopAdvertisingAndListening:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString * callbackId) {
        NSError *error = nil;
        [appContext stopAdvertisingAndListeningAndReturnError:&error];
        [self handleCallback:callbackId error:error];
    } withName:[AppContextJSEvent stopAdvertisingAndListening]];
}

- (void)defineMultiConnect:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        [appContext multiConnectToPeer:params validationCompletionHandler:^(NSError *error) {
            [self handleCallback:callbackId error:error];
        }];
    } withName:[AppContextJSEvent multiConnect]];
}

- (void)defineKillConnections:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        NSError *error = nil;
        [appContext killConnection:params error:&error];
        [self handleCallback:callbackId error:error];
    } withName:[AppContextJSEvent killConnections]];
}

- (void)defineDidRegisterToNative:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        NSError *error = nil;
        [appContext didRegisterToNative: params error:&error];
        [self handleCallback:callbackId error:error];

    } withName:[AppContextJSEvent didRegisterToNative]];
}

- (void)defineGetOSVersion:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        NSString * const version = [appContext getIOSVersion];
        [JXcore callEventCallback:callbackId withParams:@[version]];
    } withName:[AppContextJSEvent getOSVersion]];
}

- (void)defineDisconnect:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        NSError *error = nil;
        [appContext disconnect: params error:&error];
        [self handleCallback:callbackId error:error];

    } withName:[AppContextJSEvent disconnect]];
}

- (void)defineConnect:(AppContext *)appContext {
    [JXcore addNativeBlock:^(NSArray * params, NSString *callbackId) {
        [JXcore callEventCallback:callbackId withJSON:[appContext connect:params]];
    } withName:[AppContextJSEvent connect]];
}

#ifdef TEST
- (void)defineExecuteNativeTests:(AppContext *)appContext {
  [JXcore addNativeBlock:^(NSArray *params, NSString *callbackId) {
    id<TestRunnerProtocol> testRunner = (id<TestRunnerProtocol>)appContext;

    if (testRunner != nil) {
      NSString *result = [testRunner runNativeTests];
      [JXcore callEventCallback:callbackId withJSON:result];
    } else {
      [JXcore callEventCallback:callbackId withParams:@[@"Method not available"]];
    }
  } withName:[AppContextJSEvent executeNativeTests]];
}
#endif

@end

@implementation JXcoreExtension(AppContextDelegate)

- (void)context:(AppContext * _Nonnull)context didChangePeerAvailability:(NSString * _Nonnull)peers {
    [JXcore callEventCallback:[AppContextJSEvent peerAvailabilityChanged]
                     withJSON:peers];
}

- (void)context:(AppContext * _Nonnull)context didChangeNetworkStatus:(NSString * _Nonnull)status {
    [JXcore callEventCallback:[AppContextJSEvent networkChanged]
                     withJSON:status];
}

- (void)context:(AppContext * _Nonnull)context didUpdateDiscoveryAdvertisingState:(NSString * _Nonnull)discoveryAdvertisingState {
    [JXcore callEventCallback:[AppContextJSEvent discoveryAdvertisingStateUpdateNonTCP]
                     withJSON:discoveryAdvertisingState];
}

- (void)context:(AppContext * _Nonnull)context didFailIncomingConnectionToPort:(uint16_t)port {
    [JXcore callEventCallback:[AppContextJSEvent incomingConnectionToPortNumberFailed] withParams:@[@(port)]];
}

- (void)appWillEnterBackgroundWith:(AppContext * _Nonnull)context {
    [JXcore callEventCallback:[AppContextJSEvent appEnteringBackground] withParams:@[]];
}

- (void)appDidEnterForegroundWith:(AppContext * _Nonnull)context {
    [JXcore callEventCallback:[AppContextJSEvent appEnteredForeground] withParams:@[]];
}

- (void)context:(AppContext * _Nonnull)context didResolveMultiConnectWithSyncValue:(NSString * _Nonnull)value error:(NSObject * _Nullable)error listeningPort:(NSObject * _Nullable)listeningPort {
    [JXcore callEventCallback:[AppContextJSEvent multiConnectResolved] withParams:@[value, error, listeningPort]];
}

- (void)context:(AppContext * _Nonnull)context didFailMultiConnectConnectionWith:(NSString * _Nonnull)parameters {
    [JXcore callEventCallback:[AppContextJSEvent multiConnectConnectionFailure] withJSON:parameters];
}

@end
